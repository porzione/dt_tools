#!/usr/bin/env ruby
# frozen_string_literal: true

require 'pp'
require 'optparse'
require_relative 'models'

# TODO: OO

class Db
  def initialize
    @o = Struct.new(:v, :vv, :c, :f, :r, :s, :mh).new
    OptionParser.new do |opts|
      opts.on('-s',   'stats')      { @o.s  = true }
      opts.on('--mh', 'multi hier') { @o.mh = true }
      opts.on('-r',   'rolls')      { @o.r  = true }
      opts.on('-c',   'cleanup')    { @o.c  = true }
      opts.on('-f',   'fixdb')      { @o.f  = true }
      opts.on('-v',   'verbose')    { @o.v  = true }
      opts.on('--vv', 'very -v')    { @o.vv = true }
      @opts = opts
    end.parse!
    @o.v = true if @o.vv
  end

  def go
    if @o.s
      stats
    elsif @o.mh
      multi_hier
    elsif @o.r
      clean_rolls
    elsif @o.c
      cleanup
    elsif @o.f
      fixdb
    else
      puts @opts
    end
  end

  private

  def stats
    puts "rolls:    #{FilmRoll.count}"
    puts "images:   #{Image.count}"
    puts "u.images: #{Image.distinct.select(:filename).count}"
    puts "t.images: #{TaggedImage.count}"
    puts "u.tags:   #{UsedTag.count}"
    puts "metadata: #{MetaData.count}"
    puts "tags:     #{Tag.count}"
  end

  # find images with more than one hierarchical tag
  def multi_hier
    Image.each do |i|
      tids = TaggedImage.where(imgid: i.id).select_map(:tagid)
      next if tids.empty?

      ht = UsedTag
           .where(id: tids).select_map(:name)
           .reject { |t| t.start_with? 'darktable' }
           .select { |t| t.include? '|' }
      puts "#{i.filename} #{ht}" if ht.length > 1
    end
  end

  # delete film rolls without images
  def clean_rolls
    r_id = Sequel.qualify(FilmRoll.table_name, :id)
    i_id = Sequel.qualify(Image.table_name, :id)
    FilmRoll
      .select(r_id, :folder)
      .left_join(:images, film_id: :id)
      .group(r_id)
      .having { count(i_id) < 1 }
      .each do |r|
        res =  FilmRoll.where(id: r.id).delete
        puts "delete roll #{r.to_hash} res: #{res}"
      end
  end

  # delete data for non existent files
  def cleanup
    FilmRoll.order(:folder).all do |roll|
      Image
        .select(:id, :filename, :version)
        .where(film_id: roll.id)
        .order(:filename, :version)
        .each do |img|
        fp = "#{roll.folder}/#{img.filename}"
        next if File.exist?(fp)

        res_i = Image.where(id: img.id).delete
        res_m = MetaData.where(id: img.id).delete
        res_t = TaggedImage.where(imgid: img.id).delete
        puts "cleanup: #{fp} i:#{res_i} m:#{res_m} t:#{res_t}"
      end
    end
  end

  def fixdb_sql
    sql = <<~SQL
    SELECT m.id FROM meta_data m
    LEFT JOIN images i ON i.id=m.id
    GROUP BY m.id
    HAVING COUNT(i.id)==0
    SQL
    if (ids = @lib.execute(sql).flatten).length.positive?
      q = ids.map { '?' }.join(',')
      sql = %(DELETE FROM meta_data WHERE id IN (#{q}))
      @lib.execute(sql, ids)
      puts "del meta_data orphans: #{@lib.changes}"
    end
    sql = <<~SQL
    SELECT imgid FROM tagged_images
    LEFT JOIN images i ON id=imgid
    GROUP BY imgid
    HAVING COUNT(id)==0
    SQL
    if (ids = @lib.execute(sql).flatten).length.positive?
      q = ids.map { '?' }.join(',')
      sql = %(DELETE FROM tagged_images WHERE imgid IN (#{q}))
      @lib.execute(sql, ids)
      puts "del tagged_images orphans: #{@lib.changes}"
    end
  end

  # delete orphans from: # meta_data(id), tagged_images(id)
  def fixdb
    m_id = Sequel.qualify(MetaData.table_name, :id)
    i_id = Sequel.qualify(Image.table_name, :id)
    MetaData
      .select(m_id)
      .left_join(:images, id: :id)
      .group(m_id)
      .having { count(i_id) < 1 }
      .each do |id|
        puts id
      end
    TaggedImage
      .select(:imgid)
      .left_join(:images, id: :imgid)
      .group(:imgid)
      .having { count(:id) < 1 }
      .each do |id|
        puts id
      end

    # Image.db.run 'VACUUM'
    # Tag.db.run 'VACUUM'
  end

  # TODO: delele orphaned xmp
  # def clean_xmp; end
end

Db.new.go
