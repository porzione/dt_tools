#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require_relative 'models'

def tag_id(name)
  tag = Tag.find(name: name) || abort("no tag '#{name}'")
  tag.id
end

def delete(name)
  id = tag_id(name)
  puts "id: #{id}"
  printf "tags: %d\n", Tag.where(id: id).delete
  printf "used_tags: %d\n", UsedTag.where(id: id).delete
  printf "tagged_images: %d\n", TaggedImage.where(tagid: id).delete
end

def rename(oldt, newt)
  puts Tag.where(name: oldt).update(name: newt)
  puts UsedTag.where(name: oldt).update(name: newt)
  Tag.where(Sequel.like(:name, "%#{oldt}%")).each do |row|
    new_name = row.name.sub oldt, newt
    res = Tag.where(id: row.id).update(name: new_name)
    puts "#{row.name} -> #{new_name}: #{res}"
  end
  like = Sequel.like(:name, "%#{oldt}%")
  UsedTag.where(like).each do |row|
    new_name = row.name.sub oldt, newt
    res = UsedTag.where(id: row.id).update(name: new_name)
    puts "#{row.name} -> #{new_name}: #{res}"
  end
end

def stats(name)
  id = tag_id(name)
  puts "id: #{id}"
  printf "tagged_images: %d\n", TaggedImage.where(tagid: id).count
end

o = Struct.new(:delete_tag, :rename_tag, :new_tag, :st_tag).new
OptionParser.new do |opts|
  opts.on('-d TAG', 'Delete tag') { |t| o.delete_tag = t }
  opts.on('-r TAG', 'Rename tag') { |t| o.rename_tag = t }
  opts.on('-n TAG', 'New name')   { |t| o.new_tag = t }
  opts.on('-s TAG', 'Stats')      { |t| o.st_tag = t }
end.parse!

if o.delete_tag
  delete(o.delete_tag)
elsif o.rename_tag && o.new_tag
  rename(o.rename_tag, o.new_tag)
elsif o.st_tag
  stats(o.st_tag)
else
  # Tag.order(:name).each { |r| puts r.name }
  UsedTag.join(:tagged_images, tagid: :id)
         .group_and_count(:name)
         .order(:name)
         .each { |r| puts '%-5d %s' % [r[:count], r[:name]] }
end
