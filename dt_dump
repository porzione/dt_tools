#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'chronic'
require 'oj'
require_relative 'models'

# raw (sql) is always better
class Dumper
  GEO_SQL = DT::GEO.map(&:to_s).join(',')

  SQL_META = 'SELECT key, value FROM meta_data WHERE id=?'
  SQL_IMGS = <<~SQL
  SELECT id, filename, version, write_timestamp, #{GEO_SQL}
  FROM images WHERE film_id=? ORDER BY filename, version
  SQL
  SQL_TAGS = <<~SQL
  SELECT name FROM used_tags
  JOIN tagged_images ON tagid=id WHERE imgid=?
  SQL

  def initialize
    @o = Struct.new(:since).new
    OptionParser.new do |opts|
      opts.on('-s time', 'Since') { |t| @o.since = t }
    end.parse!
    if @o.since
      t = Chronic.parse(@o.since, context: :past)
      abort 'bad time since' unless t
      @o.since = t.to_i
      warn "since: #{t} #{@o.since}"
      exit
    end
    @lib = Image.db
  end

  def go
    data = {}
    FilmRoll.select(:id, :folder).order(:folder).each do |r|
      dir = r.folder
      data[dir] = {}
      @lib.fetch(SQL_IMGS, r.id).each do |i|
        meta = {
          t: i[:write_timestamp],
          k: get_meta_k(i[:id])
        }
        geo = i.slice(*DT::GEO).values.compact.map(&:to_s)
        meta[:geo] = geo unless geo.empty?
        tags = get_tags(i[:id])
        meta[:tags] = tags unless tags.empty?
        data[dir][i[:filename]] ||= {}
        data[dir][i[:filename]][i[:version]] = meta
      end
    end
    puts Oj.dump(data, indent: 2, mode: :compat)
  end

  private

  def get_tags(imgid)
    @lib
      .fetch(SQL_TAGS, imgid)
      .map { |t| t[:name] }
      .reject { |t| t.match?(/^darktable\|.+/) }
      .sort
  end

  def get_meta_k(imgid)
    @lib
      .fetch(SQL_META, imgid)
      .map(&:values)
      .to_h
  end
end

Dumper.new.go
