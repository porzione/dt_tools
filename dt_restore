#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'oj'
require 'active_support/core_ext/string'
require 'active_support/core_ext/hash'
require_relative 'models'

# All in one restore class
class Restore
  GEO = %i[longitude latitude altitude].freeze

  ImageSt = Struct.new(:file, :ver, :meta, :roll_id, :roll_name)

  Op = Struct.new :dry, :v, :vv, :force, :add, :del, :no_geo, :no_meta

  def initialize
    @ignore_tags = []
    optparse
  end

  def optparse
    @o = Op.new
    OptionParser.new do |opts|
      opts.on('-n',   'dry run') { @o.dry   = true }
      opts.on('-v',   'verbose') { @o.v     = true }
      opts.on('--vv', 'very -v') { @o.vv    = true }
      opts.on('-f',   'force')   { @o.force = true }
      opts.on('-a', 'add tags')  { @o.add = true }
      opts.on('-d', 'del tags')  { @o.del = true }
      opts.on('--ng', 'no geo')  { @o.no_geo = true }
      opts.on('--nm', 'no meta') { @o.no_meta = true }
      opts.on('-i T', 'Ignore')  { |t| @ignore_tags << t }
    end.parse!
  end

  def parse_in
    Oj.load(ARGF.read).each_pair do |roll_name, images|
      unless (roll = FilmRoll.find(folder: roll_name))
        warn "no roll: #{roll_name}"
        next
      end
      images.each_pair do |jfile|
        jfile[1].each do |ver, meta|
          process_image ImageSt.new(jfile[0], ver, meta, roll.id, roll_name)
        end
      end
    end
  end

  def process_image(img)
    puts "j: #{img.file} m:#{img.meta}" if @o.vv
    images = Image
             .select(:id, :write_timestamp, *GEO)
             .where(film_id: img.roll_id, filename: img.file, version: img.ver)
    if images.empty?
      warn "no image in db: #{img.roll_name}/#{img.file} v:#{img.ver}"
    else
      images.each do |i|
        ih = i.to_hash.select { |_, v| v }
        if ih[:write_timestamp] >= img.meta['t']
          puts "#{img.file}:#{img.ver} is newer" if @o.vv
          next unless @o.force
        elsif @o.v
          puts "#{img.file}:#{img.ver} is older"
        end
        puts "db: #{ih}" if @o.vv
        process_geo(ih, img.meta['geo']) if img.meta.key?('geo') && !@o.no_geo
        process_meta(ih, img) unless @o.no_meta
        process_tags(ih, img)
      end
    end
  end

  def process_meta(ihsh, img)
    db_k = {}
    MetaData.where(id: ihsh[:id]).each do |row|
      db_k[[row.id, row.key]] = row.value
    end
    img.meta['k'].each_pair do |k, v|
      db_kk = [ihsh[:id], k.to_i]
      if db_k[db_kk] == v
        puts "same k: #{db_kk} => #{db_k[db_kk].truncate(40)}" if @o.vv
        db_k.delete db_kk
        next
      end
      db_k.delete db_kk
      if @o.dry
        res = 'DRY'
      else
        res = MetaData
              .where(id: ihsh[:id], key: k)
              .update(value: v)
        if res.zero?
          res = MetaData
                .insert(id: ihsh[:id], key: k, value: v)
        end
      end
      puts "ch k:#{k} #{v} res:#{res}" # if @o.v
    end
    db_k.keys.each do |del|
      d_id, d_k = del
      next if d_k == 2 # title

      puts "ch del k: #{d_id} #{d_k} #{db_k[del]}" # if @o.v
      next if @o.dry

      puts MetaData.where(id: d_id, key: d_k).delete
    end
  end

  def process_tags(ihsh, img)
    tags = (img.meta['tags'] || []).sort
    imgid = ihsh[:id]
    tids = TaggedImage
           .where(imgid: imgid)
           .map(&:tagid)
    db_tags = UsedTag.where(id: tids).order(:name)
                     .select_map(:name)
                     .reject { |t| t.match?(/^darktable\|.+/) }
    puts "t:#{tags} dt:#{db_tags}" if @o.vv
    return if tags == db_tags

    photo = "#{img.roll_name}/#{img.file} #{imgid}"
    if @o.add
      diff = []
      db_tags_flat = db_tags.map { |dt| dt.split '|' }.flatten.uniq
      (tags - db_tags).each do |nt|
        next if @ignore_tags.include?(nt)

        diff << nt unless db_tags_flat.include?(nt)
      end
      unless diff.empty?
        puts "ch #{photo} add:#{diff}"
        tag_add(imgid, diff) unless @o.dry
      end
    end
    if @o.del
      diff = []
      (db_tags - tags).each do |nt|
        next if @ignore_tags.include?(nt)

        diff << nt
      end
      unless diff.empty?
        puts "ch #{photo} del:#{diff}"
        tag_del(imgid, diff) unless @o.dry
      end
    end
    puts 'tags over' if @o.vv
  end

  def tag_add(imgid, tags)
    tags.each do |t|
      u_tag = UsedTag.find(name: t)
      puts "u_tag: #{u_tag}"
      if u_tag
        puts "ch add t:#{t} id:#{u_tag.id}"
        puts TaggedImage.insert(imgid: imgid, tagid: u_tag.id)
      else
        newid = UsedTag.max(:id) + 1
        puts "ch new t:#{t} id:#{newid}"
        puts UsedTag.insert(id: newid, name: t)
        puts TaggedImage.insert(imgid: imgid, tagid: newid)
        puts Tag.insert(id: newid, name: t)
      end
    end
  end

  def tag_del(imgid, tags)
    tags.each do |t|
      id = UsedTag.find(name: t).id
      puts "ch del t:#{t} id:#{id}"
      puts TaggedImage.where(imgid: imgid, tagid: id).delete
      next unless TaggedImage.where(tagid: id).count.zero?

      r1 = UsedTag.where(id: id).delete
      r2 = Tag.where(id: id).delete
      puts "ch no more used ut:#{r1} t:#{r2}"
    end
  end

  def process_geo(ihsh, geo)
    raise 'no geo data' unless geo

    nr = { write_timestamp: Time.now.to_i }
    nr[:longitude] = geo[0] if geo[0]
    nr[:latitude]  = geo[1] if geo[1]
    nr[:altitude]  = geo[2] if geo[2]
    og = ihsh.slice(*GEO)
    ng = nr.slice(*GEO).transform_values(&:to_f)
    return if ng == og

    res = @o.dry ? 'DRY' : Image.where(id: ihsh[:id]).update(nr)
    puts "ch geo:#{ng} <- #{og} res: #{res}" if @o.v || @o.vv
  end
end

restore = Restore.new
restore.parse_in
