#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require_relative 'models'
require 'json'
require 'active_support/core_ext/string'

# All in one restore class
class Restore
  GEO = %i[longitude latitude altitude].freeze

  ImageSt = Struct.new(:file, :ver, :meta, :roll_id, :roll_name)

  Op = Struct.new :dry, :v, :vv, :force, :add, :del, :no_geo, :no_meta

  def initialize
    @ignore_tags = []
    optparse
  end

  def optparse
    @o = Op.new
    OptionParser.new do |opts|
      opts.on('-n',   'dry run') { @o.dry   = true }
      opts.on('-v',   'verbose') { @o.v     = true }
      opts.on('--vv', 'very -v') { @o.vv    = true }
      opts.on('-f',   'force')   { @o.force = true }
      opts.on('-a', 'add tags')  { @o.add = true }
      opts.on('-d', 'del tags')  { @o.del = true }
      opts.on('--ng', 'no geo')  { @o.no_geo = true }
      opts.on('--nm', 'no meta') { @o.no_meta = true }
      opts.on('-i T', 'Ignore')  { |t| @ignore_tags << t }
    end.parse!
  end

  def parse_in
    JSON.parse(ARGF.read).each_pair do |roll_name, images|
      res = FilmRoll.where(folder: roll_name)
      if res.empty?
        warn "no roll: #{roll_name}"
        next
      end
      roll_id = res.first[:id]
      images.each_pair do |jfile|
        file = jfile[0]
        jfile[1].each do |ver, meta|
          process_image ImageSt.new(file, ver, meta, roll_id, roll_name)
        end
      end
    end
  end

  def process_image(img)
    puts "j: #{img.file} m:#{img.meta}" if @o.vv
    res = Image
          .select(:id, :write_timestamp, *GEO)
          .where(film_id: img.roll_id, filename: img.file, version: img.ver)
    if res.empty?
      warn "no image in db: #{img.roll_name}/#{img.file} v:#{img.ver}"
    else
      res.each do |i|
        ih = i.to_hash.select { |_, v| v }
        if ih[:write_timestamp] >= img.meta['t']
          puts "#{img.file}:#{img.ver} is newer" if @o.vv
          next unless @o.force
        elsif @o.v
          puts "#{img.file}:#{img.ver} is older"
        end
        puts "db: #{ih}" if @o.vv
        process_geo(ih, img.meta['geo']) if img.meta.key?('geo') && !@o.no_geo
        process_meta(ih, img) unless @o.no_meta
        process_tags(ih, img)
      end
    end
  end

  def process_meta(ihsh, img)
    db_k = {}
    res = MetaData.where(id: ihsh[:id]).each do |row|
      db_k[[row[:id], row[:key]]] = row[:value]
    end
    img.meta['k'].each_pair do |k, v|
      db_kk = [ihsh[:id], k.to_i]
      if db_k[db_kk] == v
        puts "same k: #{db_kk} => #{db_k[db_kk].truncate(40)}" if @o.vv
        db_k.delete db_kk
        next
      end
      db_k.delete db_kk
      if @o.dry
        res = 'DRY'
      else
        res = MetaData
              .where(id: ihsh[:id], key: k)
              .update(value: v)
        if res.zero?
          res = MetaData
                .insert(id: ihsh[:id], key: k, value: v)
        end
      end
      puts "ch k:#{k} #{v} res:#{res}" # if @o.v
    end
    db_k.keys.each do |del|
      d_id, d_k = del
      next if d_k == 2 # title

      puts "ch del k: #{d_id} #{d_k} #{db_k[del]}" # if @o.v
      next if @o.dry

      puts MetaData.where(id: d_id, key: d_k).delete
    end
  end

  def process_tags(ihsh, img)
    # magic start
    if img.file == 'P9250533.JPG'
      old_v, old_vv = @o.v, @o.vv
      @o.v, @o.vv = true, true
    end
    tags = img.meta['tags'] || []
    imgid = ihsh[:id]
    tids = TaggedImage
           .where(imgid: imgid)
           .all.map { |t| t[:tagid] }
    db_tags = []
    db_dt_tags = []
    UsedTag.where(id: tids).map { |t| t[:name] }.each do |t|
      t.match?(/^darktable\|.+/) ? db_dt_tags.push(t) : db_tags.push(t)
    end
    puts "t:#{tags} dt:#{db_tags}" if @o.vv
    return if tags == db_tags

    photo = "#{img.roll_name}/#{img.file} #{imgid}"
    if @o.add
      diff = []
      db_tags_flat = db_tags.map { |dt| dt.split '|' }.flatten.uniq
      (tags - db_tags).each do |nt|
        next if @ignore_tags.include?(nt)
        diff << nt unless db_tags_flat.include?(nt)
      end
      unless diff.empty?
        puts "ch #{photo} add:#{diff}"
        tag_add(imgid, diff) unless @o.dry
      end
    end
    if @o.del
      diff = []
      (db_tags - tags).each do |nt|
        next if @ignore_tags.include?(nt)

        diff << nt
      end
      unless diff.empty?
        puts "ch #{photo} del:#{diff}"
        tag_del(imgid, diff) unless @o.dry
      end
    end
    puts 'tags over' if @o.vv
    # magic end
    if img.file == 'P9250533.JPG'
      @o.v, @o.vv = old_v, old_vv
    end
  end

  def tag_add(imgid, tags)
    tags.each do |t|
      res = UsedTag.where(name: t)
      if res.empty?
        newid = UsedTag.max(:id) + 1
        puts "ch new t:#{t} id:#{newid}"
        puts UsedTag.insert(id: newid, name: t)
        puts TaggedImage.insert(imgid: imgid, tagid: newid)
        puts Tag.insert(id: newid, name: t)
      else
        id = res.first[:id]
        puts "ch add t:#{t} id:#{id}"
        puts TaggedImage.insert(imgid: imgid, tagid: id)
      end
    end
  end

  def tag_del(imgid, tags)
    tags.each do |t|
      id = UsedTag.where(name: t).first[:id]
      puts "ch del t:#{t} id:#{id}"
      puts TaggedImage.where(imgid: imgid, tagid: id).delete
      next unless TaggedImage.where(tagid: id).count.zero?

      r1 = UsedTag.where(id: id).delete
      r2 = Tag.where(id: id).delete
      puts "ch no more used ut:#{r1} t:#{r2}"
    end
  end

  def process_geo(ihsh, geo)
    raise 'no geo data' unless geo

    nr = { write_timestamp: Time.now.to_i }
    nr[:longitude] = geo[0] if geo[0]
    nr[:latitude]  = geo[1] if geo[1]
    nr[:altitude]  = geo[2] if geo[2]
    if ihsh.slice(*GEO) == nr.slice(*GEO)
      puts 'same geo' if @o.vv
    else
      res = @o.dry ? 'DRY' : Image.where(id: ihsh[:id]).update(nr)
      puts "ch geo: #{nr} res: #{res}" if @o.v || @o.vv
    end
  end
end

restore = Restore.new
restore.parse_in
