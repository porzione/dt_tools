#!/usr/bin/env ruby
# frozen_string_literal: true

require 'optparse'
require 'ostruct'
require 'sequel'
require 'json'
require 'active_support/core_ext/string'

ignore_tags = []
o = OpenStruct.new
OptionParser.new do |opts|
  opts.on('-n',   'dry run') { o.dry   = true }
  opts.on('-v',   'verbose') { o.v     = true }
  opts.on('--vv', 'very -v') { o.vv    = true }
  opts.on('-f',   'force')   { o.force = true }
  # tags
  opts.on('-a', 'add')       { o.add = true }
  opts.on('-d', 'del')       { o.del = true }
  opts.on('--ng', 'no geo')  { o.nogeo = true }
  opts.on('-i T', 'Ignore')  { |t| ignore_tags << t }
end.parse!

GEO = :longitude, :latitude, :altitude

db_base_path = "#{ENV['HOME']}/.config/darktable"
DB_LIB  = Sequel.connect "sqlite://#{db_base_path}/library.db"
DB_DATA = Sequel.connect "sqlite://#{db_base_path}/data.db"

def tag_add imgid, tags
  tags.each do |t|
    res = DB_LIB[:used_tags].where(name: t)
    if res.empty?
      newid = DB_LIB[:used_tags].max(:id) + 1
      puts "ch new t:#{t} id:#{newid}"
      puts DB_LIB[:used_tags].insert(id: newid, name: t)
      puts DB_LIB[:tagged_images].insert(imgid: imgid, tagid: newid)
      puts DB_DATA[:tags].insert(id: newid, name: t)
    else
      id = res.first[:id]
      puts "ch add t:#{t} id:#{id}"
      puts DB_LIB[:tagged_images].insert(imgid: imgid, tagid: id)
    end
  end
end

def tag_del imgid, tags
  tags.each do |t|
    id = DB_LIB[:used_tags].where(name: t).first[:id]
    puts "ch del t:#{t} id:#{id}"
    puts DB_LIB[:tagged_images].where(imgid: imgid, tagid: id).delete
    if DB_LIB[:tagged_images].where(tagid: id).count == 0
      r1 = DB_LIB[:used_tags].where(id: id).delete
      r2 = DB_DATA[:tags].where(id: id).delete
      puts "ch no more used ut:#{r1} t:#{r2}"
    end
  end
end


JSON.parse(ARGF.read).each_pair do |roll_name, images|

  res = DB_LIB[:film_rolls].where(folder: roll_name)
  if res.empty?
    warn "NO ROLL: #{roll_name}"
    next
  else
    roll_id = res.first[:id]
  end

  images.each_pair do |jfile|
    file = jfile[0]
    jfile[1].each do |ver, meta|
      puts "j: #{file} m:#{meta}" if o.vv
      res = DB_LIB[:images]
        .select(:id, :write_timestamp, *GEO)
        .where(film_id: roll_id, filename: file, version: ver)
      if res.empty?
        warn "NO IMAGE IN DB: #{roll_name}/#{file} v:#{ver}"
        next
      end
      res.each do |img|
        i = img.to_hash.select{ |k, v| v }
        if i[:write_timestamp] >= meta['t']
          puts "#{file}:#{ver} is newer" if o.vv
          next unless o.force
        else
          puts "#{file}:#{ver} is older" if o.v
        end
        puts "db: #{i}" if o.vv
        nr = { write_timestamp: Time.now.to_i }
        if meta.key?('geo') && !o.nogeo
          nr[:longitude] = meta['geo'][0] if meta['geo'][0]
          nr[:latitude]  = meta['geo'][1] if meta['geo'][1]
          nr[:altitude]  = meta['geo'][2] if meta['geo'][2]
        end
        if i.slice(*GEO) == nr.slice(*GEO)
          puts 'same geo' if o.vv
        else
          res = o.dry ? 'DRY' : DB_LIB[:images].where(id: i[:id]).update(nr)
          puts "ch geo: #{nr} res: #{res}" if o.v || o.vv
        end
        db_k = {}
        res = DB_LIB[:meta_data].where(id: i[:id]).each do |row|
          db_k[[row[:id], row[:key]]] = row[:value]
        end
        meta['k'].each_pair do |k, v|
          db_kk = [i[:id], k.to_i]
          if db_k[db_kk] == v
            puts "same k: #{db_kk} => #{db_k[db_kk].truncate(40)}" if o.vv
            db_k.delete db_kk
            next
          end
          db_k.delete db_kk
          if o.dry
            res = 'DRY'
          else
            res = DB_LIB[:meta_data].where(id: i[:id], key: k).update(value: v)
            res = DB_LIB[:meta_data].insert(id: i[:id], key: k, value: v) if res == 0
          end
          puts "ch k:#{k} #{v} res:#{res}" # if o.v
        end
        db_k.keys.each do |del|
          d_id, d_k = del
          next if d_k == 2 # title
          puts "ch del k: #{d_id} #{d_k} #{db_k[del]}" # if o.v
          next if o.dry
          puts DB_LIB[:meta_data].where(id: d_id, key: d_k).delete
        end

        # tags
        tags = meta['tags'] || []
        imgid = i[:id]
        tids = DB_LIB[:tagged_images]
          .where(imgid: imgid)
          .all.map{ |t| t[:tagid] }
        db_tags = []
        db_dt_tags = []
        DB_LIB[:used_tags].where(id: tids).map{ |t| t[:name] }.each do |t|
          t =~ /^darktable\|.+/ ? db_dt_tags.push(t) : db_tags.push(t)
        end
        puts "t:#{tags} dt:#{db_tags}" if o.vv
        if tags != db_tags
          photo = "#{imgid} #{roll_name}/#{file}"
          if o.add
            diff = []
            (tags - db_tags).each do |nt|
              next if ignore_tags.include?(nt)
              diff << nt if db_tags.select{ |dt| "dt".index("#{nt}|") == 0 }.empty?
            end
            if diff.length > 0
              puts "ch #{photo} add:#{diff}"
              tag_add(imgid, diff) unless o.dry
            end
          end
          if o.del
            diff = []
            (db_tags - tags).each do |nt|
              next if ignore_tags.include?(nt)
              diff << nt
            end
            if diff.length > 0
              puts "ch #{photo} del:#{diff}"
              tag_del(imgid, diff) unless o.dry
            end
          end
        end
        # /tags
      end
    end
  end

end
